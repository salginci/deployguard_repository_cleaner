#!/usr/bin/env python3
"""
Generate environment files from DeployGuard secrets scan.

Creates:
1. .env file for local development
2. .env.template with placeholder values (safe to commit)
3. GitHub Actions workflow snippet

Usage:
    python generate_env_files.py --secrets-file path/to/secrets_BEFORE.json --output ./
"""

import argparse
import json
import os
import re
from datetime import datetime


def sanitize_env_name(name: str) -> str:
    """Convert to valid environment variable name."""
    # Remove DG_ prefix
    if name.startswith("DG_"):
        name = name[3:]
    
    # Replace invalid chars
    sanitized = re.sub(r'[^A-Za-z0-9_]', '_', name.upper())
    
    # Ensure doesn't start with number
    if sanitized and sanitized[0].isdigit():
        sanitized = "_" + sanitized
    
    return sanitized


def extract_clean_value(raw_value: str) -> str:
    """Extract actual secret value from JSON key patterns."""
    # Pattern: key": "value"
    match = re.search(r'^\w+["\']?\s*:\s*["\'](.+?)["\']?$', raw_value)
    if match:
        return match.group(1)
    
    # Pattern: key = "value"
    match = re.search(r'^\w+\s*=\s*["\'](.+?)["\']$', raw_value)
    if match:
        return match.group(1)
    
    return raw_value


def categorize_secret(secret_type: str) -> str:
    """Categorize secrets for organized output."""
    categories = {
        "database": ["sqlserver", "database_password", "mongodb", "mysql", "postgres"],
        "api_keys": ["api_key", "gcp_api_key", "aws_key"],
        "auth": ["jwt", "oauth", "bearer", "private_key", "rsa_key", "azure_client_secret"],
        "cloud": ["azure", "aws", "gcp", "firebase"],
        "other": ["generic_secret", "base64_secret"]
    }
    
    secret_type_lower = secret_type.lower()
    for category, types in categories.items():
        if any(t in secret_type_lower for t in types):
            return category
    return "other"


def load_secrets(filepath: str) -> list[dict]:
    """Load secrets from DeployGuard JSON."""
    with open(filepath, 'r') as f:
        data = json.load(f)
    return data.get("secrets", [])


def generate_env_file(secrets: list[dict], output_dir: str, include_values: bool = True) -> str:
    """Generate .env or .env.template file."""
    
    lines = [
        f"# {'Environment Variables' if include_values else 'Environment Template'}",
        f"# Generated by DeployGuard on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        f"# {'‚ö†Ô∏è  DO NOT COMMIT THIS FILE!' if include_values else 'Safe to commit - contains only placeholders'}",
        "",
    ]
    
    # Group by category
    categorized = {}
    processed = set()
    
    for secret in secrets:
        env_var = secret.get("env_var", "")
        raw_value = secret.get("value", "")
        secret_type = secret.get("type", "unknown")
        
        if not raw_value:
            continue
        
        name = sanitize_env_name(env_var)
        if name in processed:
            continue
        processed.add(name)
        
        category = categorize_secret(secret_type)
        if category not in categorized:
            categorized[category] = []
        
        clean_value = extract_clean_value(raw_value)
        categorized[category].append({
            "name": name,
            "value": clean_value,
            "type": secret_type
        })
    
    # Output by category
    category_titles = {
        "database": "Database Connections",
        "api_keys": "API Keys",
        "auth": "Authentication & Security",
        "cloud": "Cloud Services",
        "other": "Other Secrets"
    }
    
    for category in ["database", "api_keys", "auth", "cloud", "other"]:
        if category not in categorized:
            continue
        
        lines.append(f"# ===== {category_titles[category]} =====")
        
        for item in categorized[category]:
            lines.append(f"# Type: {item['type']}")
            if include_values:
                # Escape special characters for .env
                value = item['value'].replace('"', '\\"')
                lines.append(f'{item["name"]}="{value}"')
            else:
                lines.append(f'{item["name"]}="<your-{item["type"]}-here>"')
        
        lines.append("")
    
    content = "\n".join(lines)
    
    filename = ".env" if include_values else ".env.template"
    filepath = os.path.join(output_dir, filename)
    
    with open(filepath, 'w') as f:
        f.write(content)
    
    return filepath


def generate_github_actions_snippet(secrets: list[dict], output_dir: str) -> str:
    """Generate GitHub Actions workflow snippet."""
    
    processed = set()
    secret_names = []
    
    for secret in secrets:
        env_var = secret.get("env_var", "")
        if not secret.get("value"):
            continue
        
        name = sanitize_env_name(env_var)
        if name in processed:
            continue
        processed.add(name)
        secret_names.append(name)
    
    lines = [
        "# GitHub Actions Workflow Snippet",
        f"# Generated by DeployGuard on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        "",
        "# Add this to your workflow file (.github/workflows/*.yml)",
        "",
        "env:",
    ]
    
    for name in sorted(secret_names):
        lines.append(f"  {name}: ${{{{ secrets.{name} }}}}")
    
    lines.extend([
        "",
        "# Or use in a specific step:",
        "steps:",
        "  - name: Deploy",
        "    env:",
    ])
    
    for name in sorted(secret_names)[:5]:  # Show first 5 as example
        lines.append(f"      {name}: ${{{{ secrets.{name} }}}}")
    
    if len(secret_names) > 5:
        lines.append(f"      # ... and {len(secret_names) - 5} more secrets")
    
    content = "\n".join(lines)
    
    filepath = os.path.join(output_dir, "github_actions_secrets.yml")
    with open(filepath, 'w') as f:
        f.write(content)
    
    return filepath


def generate_docker_env_file(secrets: list[dict], output_dir: str) -> str:
    """Generate docker-compose compatible env_file."""
    
    lines = [
        "# Docker Environment File",
        f"# Generated by DeployGuard on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        "# Use with: docker-compose --env-file docker.env up",
        "",
    ]
    
    processed = set()
    
    for secret in secrets:
        env_var = secret.get("env_var", "")
        raw_value = secret.get("value", "")
        
        if not raw_value:
            continue
        
        name = sanitize_env_name(env_var)
        if name in processed:
            continue
        processed.add(name)
        
        clean_value = extract_clean_value(raw_value)
        # Docker env files don't need quotes
        lines.append(f"{name}={clean_value}")
    
    content = "\n".join(lines)
    
    filepath = os.path.join(output_dir, "docker.env")
    with open(filepath, 'w') as f:
        f.write(content)
    
    return filepath


def main():
    parser = argparse.ArgumentParser(
        description="Generate environment files from DeployGuard secrets scan"
    )
    parser.add_argument(
        "--secrets-file", "-f",
        required=True,
        help="Path to DeployGuard secrets JSON file"
    )
    parser.add_argument(
        "--output", "-o",
        default=".",
        help="Output directory (default: current directory)"
    )
    parser.add_argument(
        "--formats",
        nargs="+",
        default=["env", "template", "github", "docker"],
        choices=["env", "template", "github", "docker"],
        help="Output formats to generate"
    )
    
    args = parser.parse_args()
    
    # Validate input
    if not os.path.exists(args.secrets_file):
        print(f"‚ùå Secrets file not found: {args.secrets_file}")
        return 1
    
    # Create output directory
    os.makedirs(args.output, exist_ok=True)
    
    # Load secrets
    secrets = load_secrets(args.secrets_file)
    if not secrets:
        print("‚ùå No secrets found in file")
        return 1
    
    print("=" * 60)
    print("üîê Environment File Generator")
    print("=" * 60)
    print(f"Input: {args.secrets_file}")
    print(f"Output: {args.output}")
    print(f"Secrets found: {len(secrets)}")
    print("=" * 60)
    
    generated = []
    
    if "env" in args.formats:
        filepath = generate_env_file(secrets, args.output, include_values=True)
        generated.append(filepath)
        print(f"‚úÖ Generated: {filepath}")
    
    if "template" in args.formats:
        filepath = generate_env_file(secrets, args.output, include_values=False)
        generated.append(filepath)
        print(f"‚úÖ Generated: {filepath}")
    
    if "github" in args.formats:
        filepath = generate_github_actions_snippet(secrets, args.output)
        generated.append(filepath)
        print(f"‚úÖ Generated: {filepath}")
    
    if "docker" in args.formats:
        filepath = generate_docker_env_file(secrets, args.output)
        generated.append(filepath)
        print(f"‚úÖ Generated: {filepath}")
    
    print("\n" + "=" * 60)
    print("üìÅ Generated Files:")
    for f in generated:
        print(f"   - {f}")
    
    print("\n‚ö†Ô∏è  SECURITY REMINDERS:")
    print("   - Add .env and docker.env to .gitignore")
    print("   - Never commit actual secret values")
    print("   - Use .env.template as a reference for team members")
    print("   - Store production secrets in GitHub Secrets or a vault")
    
    return 0


if __name__ == "__main__":
    exit(main())

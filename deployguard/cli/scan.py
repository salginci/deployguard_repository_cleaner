"""
DeployGuard CLI - Scan Command

Provides commands for scanning repositories for secrets with:
- Comprehensive detection of hardcoded values
- Detailed variable name and value reporting
- Export to various formats
- Interactive selection for masking
"""
import os
import json
import csv
import click
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime

from deployguard.core.scanner import SecretScanner
from deployguard.core.history_cleaner import GitHistoryCleaner, SecretMatch
from deployguard.core.models import Severity, Finding


@click.group()
def scan():
    """üîç Scan repositories for exposed secrets."""
    pass


def format_finding_table(findings: List[Finding]) -> None:
    """Display findings in a formatted table with variable names and values."""
    if not findings:
        click.echo("\n‚úÖ No secrets or hardcoded values found!")
        return
    
    click.echo("\n" + "=" * 100)
    click.echo("DETAILED FINDINGS")
    click.echo("=" * 100)
    click.echo(f"{'#':<4} {'SEV':<8} {'TYPE':<18} {'VARIABLE':<25} {'VALUE':<30} {'FILE:LINE':<30}")
    click.echo("-" * 100)
    
    for i, finding in enumerate(findings, 1):
        severity_emoji = {
            "critical": "üî¥",
            "high": "üü†",
            "medium": "üü°",
            "low": "üü¢"
        }
        emoji = severity_emoji.get(finding.severity.value, "‚ö™")
        
        # Extract variable name and value from metadata
        var_name = finding.metadata.get("variable_name", finding.suggested_variable) or "-"
        actual_value = finding.metadata.get("actual_value", "")
        
        # Truncate and mask value for display
        if actual_value:
            if len(actual_value) > 25:
                display_value = actual_value[:10] + "..." + actual_value[-8:]
            else:
                display_value = actual_value
        else:
            display_value = finding.exposed_value[:25] + "..." if len(finding.exposed_value) > 25 else finding.exposed_value
        
        file_loc = f"{Path(finding.file_path).name}:{finding.line_number}"
        
        click.echo(
            f"{i:<4} {emoji} {finding.severity.value:<6} {finding.type.value:<18} "
            f"{var_name:<25} {display_value:<30} {file_loc:<30}"
        )


def export_findings_json(findings: List[Finding], output_path: str, scan_path: str) -> None:
    """Export findings to JSON format."""
    data = {
        "scan_date": datetime.now().isoformat(),
        "scanned_path": os.path.abspath(scan_path),
        "total_findings": len(findings),
        "findings": [
            {
                "id": i + 1,
                "type": f.type.value,
                "severity": f.severity.value,
                "file_path": f.file_path,
                "line_number": f.line_number,
                "variable_name": f.metadata.get("variable_name") or f.suggested_variable,
                "actual_value": f.metadata.get("actual_value") or f.exposed_value,
                "full_match": f.exposed_value,
                "suggested_env_var": f.suggested_variable,
                "description": f.description,
                "remediation": f.remediation,
                "context": f.context,
            }
            for i, f in enumerate(findings)
        ],
    }
    
    with open(output_path, "w") as fp:
        json.dump(data, fp, indent=2)


def export_findings_csv(findings: List[Finding], output_path: str) -> None:
    """Export findings to CSV format."""
    with open(output_path, "w", newline="") as fp:
        writer = csv.writer(fp)
        writer.writerow([
            "ID", "Severity", "Type", "Variable Name", "Actual Value", 
            "Suggested Env Var", "File", "Line", "Description"
        ])
        
        for i, f in enumerate(findings, 1):
            writer.writerow([
                i,
                f.severity.value,
                f.type.value,
                f.metadata.get("variable_name") or f.suggested_variable or "-",
                f.metadata.get("actual_value") or f.exposed_value,
                f.suggested_variable or "-",
                f.file_path,
                f.line_number,
                f.description,
            ])


def export_findings_purge(findings: List[Finding], output_path: str, use_env_vars: bool = False) -> None:
    """Export findings as secrets_to_purge.txt (BFG-compatible format)."""
    with open(output_path, "w") as fp:
        fp.write("# Secrets to purge - Generated by DeployGuard\n")
        fp.write(f"# Generated: {datetime.now().isoformat()}\n")
        fp.write("# Format: secret_value==>replacement (or just secret_value for ***REMOVED***)\n\n")
        
        seen_values = set()
        for f in findings:
            value = f.metadata.get("actual_value") or f.exposed_value
            if value and value not in seen_values:
                seen_values.add(value)
                if use_env_vars and f.suggested_variable:
                    fp.write(f"{value}==>${{{f.suggested_variable}}}\n")
                else:
                    fp.write(f"{value}\n")


def export_env_template(findings: List[Finding], output_path: str) -> None:
    """Generate .env.template file with suggested variable names."""
    env_vars = {}
    
    for f in findings:
        var_name = f.metadata.get("variable_name") or f.suggested_variable
        if var_name and var_name not in env_vars:
            env_vars[var_name] = {
                "type": f.type.value,
                "description": f.description,
                "files": [f.file_path],
            }
        elif var_name and var_name in env_vars:
            if f.file_path not in env_vars[var_name]["files"]:
                env_vars[var_name]["files"].append(f.file_path)
    
    with open(output_path, "w") as fp:
        fp.write("# Environment Variables Template\n")
        fp.write("# Generated by DeployGuard Repository Cleaner\n")
        fp.write(f"# Generated: {datetime.now().isoformat()}\n")
        fp.write("# Replace placeholder values with actual secrets\n\n")
        
        for var_name, info in sorted(env_vars.items()):
            fp.write(f"# Type: {info['type']}\n")
            fp.write(f"# Found in: {', '.join(info['files'][:3])}\n")
            fp.write(f"{var_name}=your_value_here\n\n")


@scan.command("local")
@click.option(
    "--path", "-p",
    type=click.Path(exists=True),
    default=".",
    help="Path to local repository or directory to scan"
)
@click.option(
    "--patterns", "-c",
    type=click.Path(exists=True),
    help="Path to custom patterns YAML file"
)
@click.option(
    "--output", "-o",
    type=click.Path(),
    help="Output file for results (auto-detects format from extension: .json, .csv)"
)
@click.option(
    "--export-purge",
    type=click.Path(),
    help="Export secrets_to_purge.txt file for cleaning"
)
@click.option(
    "--export-env",
    type=click.Path(),
    help="Export .env.template file with suggested variable names"
)
@click.option(
    "--min-severity",
    type=click.Choice(["low", "medium", "high", "critical"]),
    default="low",
    help="Minimum severity level to report"
)
@click.option(
    "--include-history/--no-history",
    default=False,
    help="Also scan git history (all commits)"
)
@click.option(
    "--interactive/--no-interactive",
    default=False,
    help="Interactive mode: select which findings to mask"
)
@click.option(
    "--use-env-vars/--use-removed",
    default=True,
    help="Use ${VAR_NAME} placeholders instead of ***REMOVED***"
)
@click.pass_context
def scan_local(ctx, path: str, patterns: Optional[str], output: Optional[str], 
               export_purge: Optional[str], export_env: Optional[str],
               min_severity: str, include_history: bool, interactive: bool, use_env_vars: bool):
    """
    Scan a local directory or repository for secrets and hardcoded values.
    
    Detects:
    ‚Ä¢ Passwords, API keys, tokens
    ‚Ä¢ Database credentials (host, user, password, port, name)
    ‚Ä¢ Hostnames, IP addresses, URLs
    ‚Ä¢ Any hardcoded configuration values
    
    Examples:
        deployguard scan local --path /path/to/repo
        deployguard scan local --path . --output findings.json
        deployguard scan local -p ./myproject --export-purge secrets.txt --export-env .env.template
        deployguard scan local -p . --interactive
    """
    click.echo(f"\nüîç Scanning: {os.path.abspath(path)}")
    click.echo("=" * 60)
    
    # Determine patterns file
    if not patterns:
        default_patterns = Path(__file__).parent.parent.parent / "config" / "secret_patterns.yaml"
        if default_patterns.exists():
            patterns = str(default_patterns)
    
    try:
        scanner = SecretScanner(patterns_file=patterns)
        
        # Scan current files
        click.echo("\nüìÅ Scanning current files...")
        results = scanner.scan_directory(path)
        
        all_findings: List[Finding] = []
        for file_path, findings in results.items():
            all_findings.extend(findings)
        
        # Optionally scan git history
        history_findings = []
        if include_history:
            git_dir = Path(path) / ".git"
            if git_dir.exists():
                click.echo("\nüìú Scanning git history (this may take a while)...")
                cleaner = GitHistoryCleaner(scanner=scanner)
                history_secrets = cleaner.scan_git_history(path)
                history_findings = history_secrets
                click.echo(f"   Found {len(history_secrets)} unique secrets in git history")
        
        # Filter by severity
        severity_order = {"low": 0, "medium": 1, "high": 2, "critical": 3}
        min_level = severity_order[min_severity]
        
        filtered_findings = [
            f for f in all_findings 
            if severity_order.get(f.severity.value, 0) >= min_level
        ]
        
        # Display summary
        click.echo("\n" + "=" * 60)
        click.echo("üìä SCAN SUMMARY")
        click.echo("=" * 60)
        
        # Count by severity
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for finding in filtered_findings:
            severity_counts[finding.severity.value] = severity_counts.get(finding.severity.value, 0) + 1
        
        click.echo(f"\nüî¥ Critical: {severity_counts['critical']}")
        click.echo(f"üü† High:     {severity_counts['high']}")
        click.echo(f"üü° Medium:   {severity_counts['medium']}")
        click.echo(f"üü¢ Low:      {severity_counts['low']}")
        click.echo(f"\nüìù Total findings: {len(filtered_findings)}")
        
        if history_findings:
            click.echo(f"üìú Unique secrets in history: {len(history_findings)}")
        
        # Count by type
        type_counts: Dict[str, int] = {}
        for f in filtered_findings:
            type_counts[f.type.value] = type_counts.get(f.type.value, 0) + 1
        
        if type_counts:
            click.echo("\nüìã By Type:")
            for type_name, count in sorted(type_counts.items(), key=lambda x: -x[1]):
                click.echo(f"   ‚Ä¢ {type_name}: {count}")
        
        # Display detailed table
        format_finding_table(filtered_findings[:50])  # Limit display
        
        if len(filtered_findings) > 50:
            click.echo(f"\n... and {len(filtered_findings) - 50} more findings (use --output to export all)")
        
        # Interactive selection mode
        selected_findings = filtered_findings
        if interactive and filtered_findings:
            click.echo("\n" + "=" * 60)
            click.echo("üéØ INTERACTIVE SELECTION")
            click.echo("=" * 60)
            click.echo("Select which findings to include for masking/replacement.\n")
            
            selected_findings = []
            for i, finding in enumerate(filtered_findings, 1):
                var_name = finding.metadata.get("variable_name") or finding.suggested_variable or "-"
                value = finding.metadata.get("actual_value") or finding.exposed_value
                display_value = value[:30] + "..." if len(value) > 30 else value
                
                severity_emoji = {"critical": "üî¥", "high": "üü†", "medium": "üü°", "low": "üü¢"}
                emoji = severity_emoji.get(finding.severity.value, "‚ö™")
                
                click.echo(f"{i}. {emoji} {finding.type.value}")
                click.echo(f"   Variable: {var_name}")
                click.echo(f"   Value: {display_value}")
                click.echo(f"   File: {finding.file_path}:{finding.line_number}")
                
                if click.confirm("   Include this finding?", default=True):
                    selected_findings.append(finding)
                click.echo()
            
            click.echo(f"\n‚úÖ Selected {len(selected_findings)} of {len(filtered_findings)} findings")
        
        # Export to files
        if output:
            ext = Path(output).suffix.lower()
            if ext == ".csv":
                export_findings_csv(selected_findings, output)
            else:
                export_findings_json(selected_findings, output, path)
            click.echo(f"\nüìÑ Findings exported to: {output}")
        
        if export_purge:
            export_findings_purge(selected_findings, export_purge, use_env_vars)
            click.echo(f"üìÑ Purge file exported to: {export_purge}")
        
        if export_env:
            export_env_template(selected_findings, export_env)
            click.echo(f"üìÑ Environment template exported to: {export_env}")
        
        # Next steps guidance
        if filtered_findings:
            click.echo("\n" + "-" * 60)
            click.echo("NEXT STEPS:")
            click.echo("-" * 60)
            click.echo("1. Review the findings above")
            click.echo("2. Export to files for further processing:")
            click.echo(f"   deployguard scan local -p {path} --output findings.json --export-purge secrets.txt")
            click.echo("3. To clean git history:")
            click.echo("   git clone --mirror <repo_url> repo.git")
            click.echo("   deployguard clean history --path repo.git --execute")
        
        # Exit code based on findings
        if severity_counts["critical"] > 0:
            click.echo("\n‚ö†Ô∏è  CRITICAL secrets found! Immediate action required.")
            raise SystemExit(2)
        elif severity_counts["high"] > 0:
            click.echo("\n‚ö†Ô∏è  High severity secrets found. Review recommended.")
            raise SystemExit(1)
        else:
            click.echo("\n‚úÖ Scan complete.")
            raise SystemExit(0)
            
    except SystemExit:
        raise
    except Exception as e:
        click.echo(f"\n‚ùå Error: {e}", err=True)
        import traceback
        traceback.print_exc()
        raise SystemExit(3)


@scan.command("history")
@click.option(
    "--path", "-p",
    type=click.Path(exists=True),
    default=".",
    help="Path to git repository"
)
@click.option(
    "--branch", "-b",
    help="Specific branch to scan (default: all branches)"
)
@click.option(
    "--all-branches/--single-branch",
    default=True,
    help="Scan all branches or just the specified one"
)
@click.option(
    "--output", "-o",
    type=click.Path(),
    default="secrets_to_purge.txt",
    help="Output file for purge list (BFG-compatible format)"
)
@click.option(
    "--env-template", "-e",
    type=click.Path(),
    help="Generate .env.template file with suggested variable names"
)
@click.option(
    "--use-env-vars/--use-placeholder",
    default=False,
    help="Use environment variable placeholders instead of ***REMOVED***"
)
@click.pass_context
def scan_history(ctx, path: str, branch: Optional[str], all_branches: bool,
                 output: str, env_template: Optional[str], use_env_vars: bool):
    """
    Scan git history for secrets and generate purge file.
    
    This scans all commits in the repository history and generates a
    secrets_to_purge.txt file that can be used with BFG or DeployGuard's
    built-in cleaner.
    
    Examples:
        deployguard scan history --path /path/to/repo
        deployguard scan history -p . -o secrets.txt --use-env-vars
        deployguard scan history -p ./repo -e .env.template
    """
    git_dir = Path(path) / ".git"
    if not git_dir.exists():
        # Check if it's a bare repo
        head_file = Path(path) / "HEAD"
        if not head_file.exists():
            click.echo(f"‚ùå Not a git repository: {path}", err=True)
            ctx.exit(1)
    
    click.echo(f"\nüìú Scanning git history: {os.path.abspath(path)}")
    click.echo("=" * 60)
    
    if all_branches:
        click.echo("üîÄ Scanning all branches...")
    elif branch:
        click.echo(f"üîÄ Scanning branch: {branch}")
    
    try:
        cleaner = GitHistoryCleaner()
        
        secrets = cleaner.scan_git_history(
            repo_path=path,
            branch=branch,
            include_all_branches=all_branches,
        )
        
        if not secrets:
            click.echo("\n‚úÖ No secrets found in git history!")
            ctx.exit(0)
        
        # Display findings
        click.echo(f"\nüîç Found {len(secrets)} unique secrets in history:")
        click.echo("-" * 60)
        
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        
        for i, secret in enumerate(secrets[:20], 1):
            severity_counts[secret.severity] = severity_counts.get(secret.severity, 0) + 1
            
            severity_emoji = {
                "critical": "üî¥",
                "high": "üü†",
                "medium": "üü°", 
                "low": "üü¢"
            }
            emoji = severity_emoji.get(secret.severity, "‚ö™")
            
            # Truncate and mask secret value
            masked = secret.value[:10] + "..." + secret.value[-5:] if len(secret.value) > 20 else secret.value
            
            click.echo(f"\n{i}. {emoji} [{secret.severity.upper()}] {secret.secret_type}")
            click.echo(f"   üîë Value: {masked}")
            click.echo(f"   üìù Suggested env var: {secret.suggested_env_var}")
            click.echo(f"   üìú Found in {len(secret.commits)} commit(s)")
            click.echo(f"   üìÑ Files: {', '.join(secret.files[:3])}")
        
        if len(secrets) > 20:
            click.echo(f"\n... and {len(secrets) - 20} more secrets")
        
        # Summary
        click.echo("\n" + "=" * 60)
        click.echo("üìä SUMMARY")
        click.echo("=" * 60)
        click.echo(f"üî¥ Critical: {severity_counts['critical']}")
        click.echo(f"üü† High:     {severity_counts['high']}")
        click.echo(f"üü° Medium:   {severity_counts['medium']}")
        click.echo(f"üü¢ Low:      {severity_counts['low']}")
        
        # Generate purge file
        cleaner.generate_purge_file(secrets, output, use_env_vars)
        click.echo(f"\nüìÑ Purge file generated: {output}")
        
        # Generate env template if requested
        if env_template:
            cleaner.generate_env_template(secrets, env_template)
            click.echo(f"üìÑ Environment template generated: {env_template}")
        
        click.echo("\n" + "-" * 60)
        click.echo("NEXT STEPS:")
        click.echo("-" * 60)
        click.echo("1. Review the purge file and remove any false positives")
        click.echo("2. Create a mirror clone: git clone --mirror <repo_url> repo.git")
        click.echo("3. Run: deployguard clean --path repo.git")
        click.echo("4. Or use BFG: java -jar bfg.jar --replace-text secrets_to_purge.txt repo.git")
        
        ctx.exit(0 if severity_counts["critical"] == 0 else 2)
        
    except Exception as e:
        click.echo(f"\n‚ùå Error: {e}", err=True)
        ctx.exit(3)


@scan.command("remote")
@click.option(
    "--repo", "-r",
    required=True,
    help="Repository in format owner/repo (GitHub) or project/repo (Bitbucket)"
)
@click.option(
    "--platform",
    type=click.Choice(["github", "bitbucket"]),
    default="github",
    help="Platform to use"
)
@click.option(
    "--branch", "-b",
    default="main",
    help="Branch to scan"
)
@click.option(
    "--output", "-o",
    type=click.Path(),
    help="Output file for results (JSON format)"
)
@click.pass_context
def scan_remote(ctx, repo: str, platform: str, branch: str, output: Optional[str]):
    """
    Scan a remote repository for secrets.
    
    Requires authentication configured via 'deployguard auth'.
    
    Examples:
        deployguard scan remote --repo owner/repo
        deployguard scan remote -r myorg/myrepo --branch develop
    """
    from deployguard.utils.config import ConfigManager
    
    config = ConfigManager()
    
    click.echo(f"\nüîç Scanning remote repository: {repo}")
    click.echo(f"üì° Platform: {platform}")
    click.echo(f"üîÄ Branch: {branch}")
    click.echo("=" * 60)
    
    # Check for authentication
    if platform == "github":
        token = config.get("github_token")
        if not token:
            click.echo("‚ùå GitHub token not configured. Run: deployguard auth --github-token YOUR_TOKEN", err=True)
            ctx.exit(1)
    elif platform == "bitbucket":
        username = config.get("bitbucket_username")
        password = config.get("bitbucket_app_password")
        if not username or not password:
            click.echo("‚ùå Bitbucket credentials not configured. Run: deployguard auth --bitbucket", err=True)
            ctx.exit(1)
    
    try:
        # Import platform adapter
        if platform == "github":
            from deployguard.platforms.github_adapter import GitHubAdapter
            adapter = GitHubAdapter(token)
        else:
            from deployguard.platforms.bitbucket_adapter import BitbucketAdapter
            adapter = BitbucketAdapter(username, password)
        
        # Get repository content
        click.echo("\nüì• Fetching repository content...")
        
        owner, repo_name = repo.split("/")
        files = adapter.get_repository_files(owner, repo_name, branch)
        
        click.echo(f"   Found {len(files)} files to scan")
        
        # Scan files
        scanner = SecretScanner()
        all_findings = []
        
        with click.progressbar(files, label="üîç Scanning files") as file_list:
            for file_info in file_list:
                content = adapter.get_file_content(owner, repo_name, file_info["path"], branch)
                if content:
                    findings = scanner.scan_file(file_info["path"], content)
                    all_findings.extend(findings)
        
        # Display results
        click.echo("\n" + "=" * 60)
        click.echo("üìä SCAN RESULTS")
        click.echo("=" * 60)
        
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for finding in all_findings:
            severity_counts[finding.severity.value] = severity_counts.get(finding.severity.value, 0) + 1
        
        click.echo(f"\nüî¥ Critical: {severity_counts['critical']}")
        click.echo(f"üü† High:     {severity_counts['high']}")
        click.echo(f"üü° Medium:   {severity_counts['medium']}")
        click.echo(f"üü¢ Low:      {severity_counts['low']}")
        click.echo(f"\nüìù Total findings: {len(all_findings)}")
        
        if all_findings:
            click.echo("\n‚ö†Ô∏è  Secrets detected! For full history cleaning:")
            click.echo(f"   git clone --mirror https://github.com/{repo}.git repo.git")
            click.echo("   deployguard scan history --path repo.git")
        
        ctx.exit(0 if severity_counts["critical"] == 0 else 2)
        
    except Exception as e:
        click.echo(f"\n‚ùå Error: {e}", err=True)
        ctx.exit(3)
